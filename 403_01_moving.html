<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
<title>Muoversi attorno</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head>
<body background="images/back.gif">
<!--START-->

<h3>Muoversi attorno</h3>

Ovviamente, un aspetto importante dei giochi è il movimento delle istanze degli oggetti.
Ogni istanza ha due variabili built-in, x e y, che indicano la posizione
dell'istanza. (Per essere più precisi, indicano il punto in cui l'orgiine dello sprite
si trova). La posizione (0,0) è l'angolo in alto a sinistra della room. Puoi cambiare
la posizione di un'istanza cambiando le sue variabili x e y. Se vuoi
far fare dei movimenti complicati all'oggetto questo è il modo per farlo. Di solito
metti questo codice nell'evento Step.

<p>
Se l'oggetto si muove con velocità e direzione costante, c'è un modo più
semplice per fare ciò. Ogni istanza ha una velocità orizzontale (<tt>hspeed</tt>)
e una verticale (<tt>vspeed</tt>). Entrambe hanno come unità di misura il pixel per step.
Una velocità orizzontale positiva indica un moto verso destra, una negativa
verso sinistra. Una velocità verticale positiva indica un movimento verso il basso
e una negativa verso l'alto. Quindi devi impostare queste variabili solo
una volta (per esempio nell'evento Create) per dare all'istanza un movimento costante.

<p>
C'è un altro modo un po' diverso per specificare il movimento, usando una
direzione espressa in gradi, e una velocità non-negativa. Puoi impostare
e leggere queste variabili per specificare un movimento arbitrario. (Internamente
viene cambiato in valori per le variabili <tt>h/vspeed</tt>). Inoltre
c'è la frizione, la gravità e la sua direzione. Infine, 
c'è la funzione <tt>motion_add(dir,speed)</tt> per aggiungere un movimento
all'istanza corrente.

<p>
Per essere più precisi, ogni istanza possiede le seguenti variabili e funzioni
che trattano con la posizione e il movimento:

<p>
<blockquote>
  <tt><b>x</b></tt>
	La sua ascissa.<br>
  <tt><b>y</b></tt>   
	La sua ordinata.<br>
  <tt><b>xprevious</b></tt>   
	L'ascissa precedente.<br>
  <tt><b>yprevious</b></tt>   
	L'ordinata precedente.<br>
  <tt><b>xstart</b></tt>   
	L'ascissa iniziale nella room.<br>
  <tt><b>ystart</b></tt>   
	L'ordinata iniziale nella room.<br>
  <tt><b>hspeed</b></tt>   
	La componente orizzontale della velocità.<br>
  <tt><b>vspeed</b></tt>   
	La componente verticale della velocità.<br>
  <tt><b>direction</b></tt>
	La direzione (0-360, in senso antiorario, 0 = destra).<br>
  <tt><b>speed</b></tt>
	La velocità corrente (pixel / step).<br>
  <tt><b>friction</b></tt>
	La frizione corrente (pixel / step).<br>
  <tt><b>gravity</b></tt>
	La quantità attuale di gravità (pixel / step).<br>
  <tt><b>gravity_direction</b></tt>
	Direzione della gravità (270 = verso sotto).<br>
  <tt><b>motion_set(dir,speed)</b></tt>
	Imposta il movimento con la velocità e la direzione data.<br>
  <tt><b>motion_add(dir,speed)</b></tt>
	Aggiunge il movimento a quello attuale (è una somma tra vettori).<br>
</blockquote>

<p>
Ci sono molte funzioni disponibili che ti permettono di definire i tuoi movimenti:

<p>
<blockquote>
  <tt><b>place_free(x,y)</b></tt>
    Returns whether the instance placed at position(x,y) is collision-free. 
	This is typically used as a check before actually moving to the new position.<br>
  <tt><b>place_empty(x,y)</b></tt>
    Returns whether the instance placed at position (x,y) meets nobody. 
	So this function takes also non-solid instances into account.<br>
  <tt><b>place_meeting(x,y,obj)</b></tt>
    Returns whether the instance placed at position (x,y) meets obj. 
	obj can be an object in which case the function returns true is some 
	instance of that object is met. It can also be an instance id, the 
	special word all meaning an instance of any object, or the special word other.<br>
  <tt><b>place_snapped(hsnap,vsnap)</b></tt>
    Returns whether the instance is aligned with the snapping values.<br>
  <tt><b>move_random(hsnap,vsnap)</b></tt>
    Moves the instance to a free random, snapped position, like the corresponding action.<br>
  <tt><b>move_snap(hsnap,vsnap)</b></tt>
    Snaps the instance, like the corresponding action.<br>
  <tt><b>move_wrap(hor,vert,margin)</b></tt>
    Wraps the instance when it has left the room to the other side. <tt>hor</tt>
	indicates whether to wrap horizontaly and <tt>vert</tt> indicates whether
	to wrap vertically. <tt>margin</tt> indicates how far the origin of the
	instance must be outside the room before the wrap happens. So it is a
	margin around the room. You typically use this function in the Outside
	event.<br>
  <tt><b>move_towards_point(x,y,sp)</b></tt>
    Moves the instances with speed sp toward position (x,y).<br>
  <tt><b>move_bounce_solid(adv)</b></tt>
    Bounces against solid instances, like the corresponding action. adv 
	indicates whether to use advance bounce, that also takes slanted walls into account.<br>
  <tt><b>move_bounce_all(adv)</b></tt>
    Bounces against all instances, instead of just the solid ones.<br>
  <tt><b>move_contact_solid(dir,maxdist)</b></tt>
    Moves the instance in the direction until a contact position with a solid 
	object is reached. If there is no collision at the current position, the 
	instance is placed just before a collision occurs. If there already is a 
	collision the instance is not moved. You can specify the maximal distance 
	to move (use a negative number for an arbitrary distance).<br>
  <tt><b>move_contact_all(dir,maxdist)</b></tt>
    Same as the previous function but this time you stop at a contact with 
	any object, not just solid objects.<br>
  <tt><b>move_outside_solid(dir,maxdist)</b></tt>
    Moves the instance in the direction until it no longer lies within a solid object. 
	If there is no collision at the current position the instance is not moved. 
	You can specify the maximal distance to move (use a negative number for an 
	arbitrary distance).<br>
  <tt><b>move_outside_all(dir,maxdist)</b></tt>
    Same as the previous function but this time you move until outside any object, 
	not just solid objects.<br>
  <tt><b>distance_to_point(x,y)</b></tt>
    Returns the distance of the bounding box of the current instance to (x,y). (If the instance
	does not have a sprite or mask, the result of the function is undefined.)<br>
  <tt><b>distance_to_object(obj)</b></tt>
    Returns the distance of the instance to the nearest instance of object obj. (If the instance
	or object does not have a sprite or mask, the result of the function is undefined.)<br>
  <tt><b>position_empty(x,y)</b></tt>
    Returns whether there is nothing at position (x,y).<br>
  <tt><b>position_meeting(x,y,obj)</b></tt>
    Returns whether at position (x,y) there is an instance obj. obj can be an object, an instance 
	id, or the keywords <tt>self</tt>, <tt>other</tt>, or <tt>all</tt>.<br>
</blockquote>


<!--END-->
</body>
</html>

<!-- KEYWORDS
motion
distance
moving
instance variables
positions

x
y
xprevious
yprevious
xstart
ystart
hspeed
vspeed
direction
speed
friction
gravity
gravity_direction
motion_set()
motion_add()
place_free()
place_empty()
place_meeting()
place_snapped()
move_random()
move_snap()
move_wrap()
move_towards_point()
move_contact_solid()
move_contact_all()
move_outside_solid()
move_outside_all()
move_bounce_solid()
move_bounce_all()
distance_to_point()
distance_to_object()
position_empty()
position_meeting()

--> 
